name: Deploy to Host (password SSH + healthchecks)

on:
  push:
    branches:
      - main

jobs:

  # -----------------------
  # BACKEND TESTS (comentado)
  # -----------------------
  # backend-tests:
  #   runs-on: ubuntu-latest
  #   steps:
  #     - name: Checkout
  #       uses: actions/checkout@v4
  #     - name: Setup Java
  #       uses: actions/setup-java@v4
  #       with:
  #         distribution: temurin
  #         java-version: '17'
  #     - name: Run backend tests
  #       run: |
  #         cd Backend
  #         ./mvnw test

  # -----------------------
  # FRONTEND TESTS (comentado)
  # -----------------------
  # frontend-tests:
  #   runs-on: ubuntu-latest
  #   steps:
  #     - name: Checkout
  #       uses: actions/checkout@v4
  #     - name: Setup Node
  #       uses: actions/setup-node@v4
  #       with:
  #         node-version: 18
  #     - name: Install & Run frontend tests
  #       run: |
  #         cd Frontend
  #         npm ci
  #         npm test

  # -----------------------
  # DB SMOKE TEST (comentado)
  # -----------------------
  # db-smoke-test:
  #   runs-on: ubuntu-latest
  #   steps:
  #     - name: Simple DB smoke test (placeholder)
  #       run: |
  #         echo "AquÃ­ puedes ejecutar pg_isready/psql contra la DB o un script de comprobaciÃ³n"

  # -----------------------
  # SECURITY SCAN (comentado)
  # -----------------------
  # security-scan:
  #   runs-on: ubuntu-latest
  #   steps:
  #     - name: Trivy scan (ejemplo)
  #       uses: aquasecurity/trivy-action@master
  #       with:
  #         image-ref: 'personalfit-backend:latest' # ajustar si querÃ©s escanear imÃ¡genes


  deploy:
    environment: Production
    runs-on: ubuntu-latest
    env:
      SSH_HOST: ${{ secrets.SSH_HOST }}
      SSH_PORT: ${{ secrets.SSH_PORT }}
      SSH_USERNAME: ${{ secrets.SSH_USERNAME }}
      SSH_PASSWORD: ${{ secrets.SSH_PASSWORD }}
      JWT_SECRET: ${{ secrets.JWT_SECRET }}
      MP_ACCESS_TOKEN: ${{ secrets.MP_ACCESS_TOKEN }}
      NEXT_PUBLIC_MP_PUBLIC_KEY: ${{ secrets.NEXT_PUBLIC_MP_PUBLIC_KEY }}
    steps:
      - name: Checkout repo (opcional para tests)
        uses: actions/checkout@v4

      - name: Sanity check de secrets
        run: |
          for v in SSH_HOST SSH_PORT SSH_USERNAME SSH_PASSWORD JWT_SECRET MP_ACCESS_TOKEN NEXT_PUBLIC_MP_PUBLIC_KEY; do
            if [ -z "${!v}" ] || [ "${!v}" = "null" ]; then
              echo "Falta variable $v (revisa environment/Production o nombres)"; exit 1
            fi
          done

      - name: Install sshpass (para autenticaciÃ³n por usuario+password)
        run: sudo apt-get update && sudo apt-get install -y sshpass

      - name: Install Docker Compose V2
        run: |
          sudo curl -L "https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
          sudo chmod +x /usr/local/bin/docker-compose
          docker-compose --version

      - name: Deploy to host (ssh via password) and wait healthchecks
        run: |
          # default port
          if [ -z "${SSH_PORT}" ] || [ "${SSH_PORT}" = "null" ]; then
            SSH_PORT=22
          fi

          echo "Conectando a ${SSH_USERNAME}@${SSH_HOST}:${SSH_PORT} ..."
          sshpass -p "${SSH_PASSWORD}" ssh -o StrictHostKeyChecking=no -p "${SSH_PORT}" "${SSH_USERNAME}@${SSH_HOST}" bash -lc '
            set -euo pipefail

            DEPLOY_DIR=/opt/Personal-Fit-Santa-Fe
            echo "==> Entrando en $DEPLOY_DIR"
            cd "$DEPLOY_DIR" || { echo "ERROR: Directorio $DEPLOY_DIR no existe"; exit 2; }

            echo "==> Creando backup de la base de datos..."
            mkdir -p /opt/backup
            BACKUP_FILE="/opt/backup/backup_$(date +%Y%m%d_%H%M%S).sql"

            # Verificar que PostgreSQL estÃ© funcionando antes del backup
            if ! docker-compose exec -T postgres pg_isready -U postgres; then
              echo "ERROR: PostgreSQL no estÃ¡ listo para backup"
              exit 3
            fi

            # Crear backup
            if docker-compose exec -T postgres pg_dump -U postgres -d personalfit > "$BACKUP_FILE"; then
              echo "âœ… Backup creado: $BACKUP_FILE"
              echo "ðŸ“Š TamaÃ±o: $(du -h "$BACKUP_FILE" | cut -f1)"
            else
              echo "ERROR: FallÃ³ la creaciÃ³n del backup"
              exit 4
            fi

            echo "==> Actualizando repo (origin/main)"
            git fetch --all --prune
            git reset --hard origin/main
            git pull origin main

            echo "==> Construyendo y levantando servicios"
            docker-compose up -d --build

            wait_for_healthy() {
              local container="$1"
              local timeout_seconds="${2:-180}"
              local interval=5
              local waited=0

              while [ "$waited" -lt "$timeout_seconds" ]; do
                local docker_health
                docker_health=$(docker inspect -f "{{.State.Health.Status}}" "$container" 2>/dev/null || echo "no-health-check")

                if [ "$docker_health" = "healthy" ]; then
                  echo "$(date +"%F %T") - $container healthy (Docker health)"
                  return 0
                elif [ "$docker_health" = "unhealthy" ]; then
                  echo "$(date +"%F %T") - $container unhealthy"
                  return 2
                fi

                if [ "$container" = "personalfit-backend" ]; then
                  if curl -fsS http://localhost:8080/api/health >/dev/null 2>&1; then
                    echo "$(date +"%F %T") - Backend OK en :8080"
                    return 0
                  fi
                elif [ "$container" = "personalfit-frontend" ]; then
                  if curl -fsS http://localhost:3000 >/dev/null 2>&1; then
                    echo "$(date +"%F %T") - Frontend OK en :3000"
                    return 0
                  fi
                fi

                echo "$(date +"%F %T") - Esperando $container... (${waited}s/${timeout_seconds}s) - Docker health: $docker_health"
                sleep $interval
                waited=$((waited + interval))
              done

              echo "TIMEOUT: $container no quedÃ³ listo tras ${timeout_seconds}s"
              return 1
            }

            echo "==> Esperando backend..."
            if ! wait_for_healthy personalfit-backend 60; then
              echo "ERROR: backend no responde -> logs:"
              docker-compose logs --no-color --timestamps personalfit-backend | tail -n 300
              exit 10
            fi

            echo "==> Esperando frontend..."
            if ! wait_for_healthy personalfit-frontend 60; then
              echo "ERROR: frontend no responde -> logs:"
              docker-compose logs --no-color --timestamps personalfit-frontend | tail -n 300
              exit 11
            fi

            echo "==> Limpieza de imÃ¡genes antiguas"
            docker image prune -f

            echo "==> Verificando integridad del backup (restauraciÃ³n temporal)"
            if docker-compose exec -T postgres psql -U postgres -c "CREATE DATABASE test_restore;" 2>/dev/null; then
              if docker-compose exec -T postgres psql -U postgres -d test_restore < "$BACKUP_FILE" 2>/dev/null; then
                USER_COUNT=$(docker-compose exec -T postgres psql -U postgres -d test_restore -t -c "SELECT COUNT(*) FROM users;" 2>/dev/null | tr -d " \n" || echo 0)
                echo "âœ… RestauraciÃ³n temporal OK (users: $USER_COUNT)"
              else
                echo "âš ï¸  No se pudo restaurar backup en base temporal"
              fi
              docker-compose exec -T postgres psql -U postgres -c "DROP DATABASE test_restore;" 2>/dev/null || true
            else
              echo "âš ï¸  No se pudo crear base temporal para test"
            fi

            echo "==> DEPLOY OK"
            echo "ðŸ’¾ Backup en: $BACKUP_FILE"
          '