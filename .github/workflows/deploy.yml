name: Deploy to Host (password SSH + healthchecks)

on:
  push:
    branches:
      - main
jobs:
  # -----------------------
  # BACKEND TESTS (comentado)
  # -----------------------
  # backend-tests:
  #   runs-on: ubuntu-latest
  #   steps:
  #     - name: Checkout
  #       uses: actions/checkout@v4
  #     - name: Setup Java
  #       uses: actions/setup-java@v4
  #       with:
  #         distribution: temurin
  #         java-version: '17'
  #     - name: Run backend tests
  #       run: |
  #         cd Backend
  #         ./mvnw test

  # -----------------------
  # FRONTEND TESTS (comentado)
  # -----------------------
  # frontend-tests:
  #   runs-on: ubuntu-latest
  #   steps:
  #     - name: Checkout
  #       uses: actions/checkout@v4
  #     - name: Setup Node
  #       uses: actions/setup-node@v4
  #       with:
  #         node-version: 18
  #     - name: Install & Run frontend tests
  #       run: |
  #         cd Frontend
  #         npm ci
  #         npm test

  # -----------------------
  # DB SMOKE TEST (comentado)
  # -----------------------
  # db-smoke-test:
  #   runs-on: ubuntu-latest
  #   steps:
  #     - name: Simple DB smoke test (placeholder)
  #       run: |
  #         echo "Aquí puedes ejecutar pg_isready/psql contra la DB o un script de comprobación"

  # -----------------------
  # SECURITY SCAN (comentado)
  # -----------------------
  # security-scan:
  #   runs-on: ubuntu-latest
  #   steps:
  #     - name: Trivy scan (ejemplo)
  #       uses: aquasecurity/trivy-action@master
  #       with:
  #         image-ref: 'personalfit-backend:latest' # ajustar si querés escanear imágenes

  deploy:
    # needs: [backend-tests, frontend-tests, db-smoke-test, security-scan] # descomentar cuando actives tests
    environment: Production
    runs-on: ubuntu-latest
    env:
      SSH_HOST: ${{ secrets.SSH_HOST }}
      SSH_PORT: ${{ secrets.SSH_PORT }}
      SSH_USERNAME: ${{ secrets.SSH_USERNAME }}
      SSH_PASSWORD: ${{ secrets.SSH_PASSWORD }}
      JWT_SECRET: ${{ secrets.JWT_SECRET }}
      MP_ACCESS_TOKEN: ${{ secrets.MP_ACCESS_TOKEN }}
      NEXT_PUBLIC_MP_PUBLIC_KEY: ${{ secrets.NEXT_PUBLIC_MP_PUBLIC_KEY }}
    steps:
      - name: Checkout repo (opcional para tests)
        uses: actions/checkout@v4

      - name: Sanity check de secrets
        run: |
          for v in SSH_HOST SSH_PORT SSH_USERNAME SSH_PASSWORD JWT_SECRET MP_ACCESS_TOKEN NEXT_PUBLIC_MP_PUBLIC_KEY; do
            if [ -z "${!v}" ] || [ "${!v}" = "null" ]; then
              echo "Falta variable $v (revisa environment/Production o nombres)"; exit 1
            fi
          done

      - name: Install sshpass (para autenticación por usuario+password)
        run: sudo apt-get update && sudo apt-get install -y sshpass

      - name: Install Docker Compose V2
        run: |
          # Instalar Docker Compose V2
          sudo curl -L "https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
          sudo chmod +x /usr/local/bin/docker-compose
          
          # Verificar instalación
          docker-compose --version
          
          # Crear alias para docker compose (V2)
          echo 'alias docker="docker"' >> ~/.bashrc
          echo 'alias "docker compose"="docker-compose"' >> ~/.bashrc
          source ~/.bashrc

      - name: Deploy to host (ssh via password) and wait healthchecks
        run: |
          # Ruta donde ya tenés tu proyecto en el servidor
          DEPLOY_DIR=/opt/Personal-Fit-Santa-Fe

          # default port si no lo pasaron
          if [ -z "${SSH_PORT}" ] || [ "${SSH_PORT}" = "null" ]; then
            SSH_PORT=22
          fi

          echo "Conectando a ${SSH_USERNAME}@${SSH_HOST}:${SSH_PORT} ..."

          sshpass -p "${SSH_PASSWORD}" ssh -o StrictHostKeyChecking=no -p "${SSH_PORT}" "${SSH_USERNAME}@${SSH_HOST}" bash -s <<'REMOTE'
            set -euo pipefail

            DEPLOY_DIR=/opt/Personal-Fit-Santa-Fe
            echo "==> Entrando en $DEPLOY_DIR"
            cd "$DEPLOY_DIR" || { echo "ERROR: Directorio $DEPLOY_DIR no existe"; exit 2; }

            echo "==> Actualizando repo (origin/main)"
            git fetch --all --prune
            git reset --hard origin/main

            echo "==> Construyendo imágenes (solo backend + frontend)"
            docker-compose down -v
            docker-compose build personalfit-backend personalfit-frontend

            echo "==> Actualizando servicios (no tocar postgres ni pgadmin)"
            docker-compose up -d --no-deps personalfit-backend personalfit-frontend

            # Función para esperar estado healthy
            wait_for_healthy() {
              local container="$1"
              local timeout_seconds="${2:-180}"
              local interval=5
              local waited=0

              while [ "$waited" -lt "$timeout_seconds" ]; do
                # Primero intentar el health check nativo de Docker
                local docker_health=$(docker inspect -f '{{.State.Health.Status}}' "$container" 2>/dev/null || echo "no-health-check")
                
                if [ "$docker_health" = "healthy" ]; then
                  echo "$(date +'%F %T') - $container is healthy (Docker health check)"
                  return 0
                elif [ "$docker_health" = "unhealthy" ]; then
                  echo "$(date +'%F %T') - $container is unhealthy (Docker health check)"
                  return 2
                fi
                
                # Si no hay health check nativo o está starting, hacer petición HTTP directa
                if [ "$container" = "personalfit-backend" ]; then
                  # Para el backend, verificar que responda en el puerto 8080
                  if curl -f -s http://localhost:8080/api/users/getAll >/dev/null 2>&1; then
                    echo "$(date +'%F %T') - Backend responding on port 8080"
                    return 0
                  fi
                elif [ "$container" = "personalfit-frontend" ]; then
                  # Para el frontend, verificar que responda en el puerto 3000
                  if curl -f -s http://localhost:3000 >/dev/null 2>&1; then
                    echo "$(date +'%F %T') - Frontend responding on port 3000"
                    return 0
                  fi
                fi
                
                echo "$(date +'%F %T') - Waiting for $container to be ready... (${waited}s/${timeout_seconds}s) - Docker health: $docker_health"
                sleep $interval
                waited=$((waited + interval))
              done

              echo "TIMEOUT: $container did not become ready after ${timeout_seconds}s"
              return 1
            }

            echo "==> Esperando que personalfit-backend esté listo..."
            if ! wait_for_healthy personalfit-backend 180; then
              echo "ERROR: backend no responde en puerto 8080 -> abortando deploy"
              docker-compose logs --no-color --timestamps personalfit-backend | tail -n 300
              exit 10
            fi

            echo "==> Esperando que personalfit-frontend esté listo..."
            if ! wait_for_healthy personalfit-frontend 180; then
              echo "ERROR: frontend no responde en puerto 3000 -> abortando deploy"
              docker-compose logs --no-color --timestamps personalfit-frontend | tail -n 300
              exit 11
            fi

            echo "==> Limpieza de imágenes antiguas"
            docker image prune -f

            echo "==> DEPLOY OK: servicios actualizados y healthy"
          REMOTE
