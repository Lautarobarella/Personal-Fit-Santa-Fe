name: Deploy to Host (password SSH + healthchecks)

on:
  push:
    branches:
      - main
jobs:
  # -----------------------
  # BACKEND TESTS (comentado)
  # -----------------------
  # backend-tests:
  #   runs-on: ubuntu-latest
  #   steps:
  #     - name: Checkout
  #       uses: actions/checkout@v4
  #     - name: Setup Java
  #       uses: actions/setup-java@v4
  #       with:
  #         distribution: temurin
  #         java-version: '17'
  #     - name: Run backend tests
  #       run: |
  #         cd Backend
  #         ./mvnw test

  # -----------------------
  # FRONTEND TESTS (comentado)
  # -----------------------
  # frontend-tests:
  #   runs-on: ubuntu-latest
  #   steps:
  #     - name: Checkout
  #       uses: actions/checkout@v4
  #     - name: Setup Node
  #       uses: actions/setup-node@v4
  #       with:
  #         node-version: 18
  #     - name: Install & Run frontend tests
  #       run: |
  #         cd Frontend
  #         npm ci
  #         npm test

  # -----------------------
  # DB SMOKE TEST (comentado)
  # -----------------------
  # db-smoke-test:
  #   runs-on: ubuntu-latest
  #   steps:
  #     - name: Simple DB smoke test (placeholder)
  #       run: |
  #         echo "AquÃ­ puedes ejecutar pg_isready/psql contra la DB o un script de comprobaciÃ³n"

  # -----------------------
  # SECURITY SCAN (comentado)
  # -----------------------
  # security-scan:
  #   runs-on: ubuntu-latest
  #   steps:
  #     - name: Trivy scan (ejemplo)
  #       uses: aquasecurity/trivy-action@master
  #       with:
  #         image-ref: 'personalfit-backend:latest' # ajustar si querÃ©s escanear imÃ¡genes

  deploy:
    # needs: [backend-tests, frontend-tests, db-smoke-test, security-scan] # descomentar cuando actives tests
    environment: Production
    runs-on: ubuntu-latest
    env:
      SSH_HOST: ${{ secrets.SSH_HOST }}
      SSH_PORT: ${{ secrets.SSH_PORT }}
      SSH_USERNAME: ${{ secrets.SSH_USERNAME }}
      SSH_PASSWORD: ${{ secrets.SSH_PASSWORD }}
      JWT_SECRET: ${{ secrets.JWT_SECRET }}
      MP_ACCESS_TOKEN: ${{ secrets.MP_ACCESS_TOKEN }}
      NEXT_PUBLIC_MP_PUBLIC_KEY: ${{ secrets.NEXT_PUBLIC_MP_PUBLIC_KEY }}
    steps:
      - name: Checkout repo (opcional para tests)
        uses: actions/checkout@v4

      - name: Sanity check de secrets
        run: |
          for v in SSH_HOST SSH_PORT SSH_USERNAME SSH_PASSWORD JWT_SECRET MP_ACCESS_TOKEN NEXT_PUBLIC_MP_PUBLIC_KEY; do
            if [ -z "${!v}" ] || [ "${!v}" = "null" ]; then
              echo "Falta variable $v (revisa environment/Production o nombres)"; exit 1
            fi
          done

      - name: Install sshpass (para autenticaciÃ³n por usuario+password)
        run: sudo apt-get update && sudo apt-get install -y sshpass

      - name: Install Docker Compose V2
        run: |
          # Instalar Docker Compose V2
          sudo curl -L "https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
          sudo chmod +x /usr/local/bin/docker-compose
          
          # Verificar instalaciÃ³n
          docker-compose --version
          
          # Crear alias para docker compose (V2)
          echo 'alias docker="docker"' >> ~/.bashrc
          echo 'alias "docker compose"="docker-compose"' >> ~/.bashrc
          source ~/.bashrc

      - name: Deploy to host (ssh via password) and wait healthchecks
        run: |
          # Ruta donde ya tenÃ©s tu proyecto en el servidor
          DEPLOY_DIR=/opt/Personal-Fit-Santa-Fe

          # default port si no lo pasaron
          if [ -z "${SSH_PORT}" ] || [ "${SSH_PORT}" = "null" ]; then
            SSH_PORT=22
          fi

          echo "Conectando a ${SSH_USERNAME}@${SSH_HOST}:${SSH_PORT} ..."

          sshpass -p "${SSH_PASSWORD}" ssh -o StrictHostKeyChecking=no -p "${SSH_PORT}" "${SSH_USERNAME}@${SSH_HOST}" bash -s <<'REMOTE'
            set -euo pipefail

            DEPLOY_DIR=/opt/Personal-Fit-Santa-Fe
            echo "==> Entrando en $DEPLOY_DIR"
            cd "$DEPLOY_DIR" || { echo "ERROR: Directorio $DEPLOY_DIR no existe"; exit 2; }

            echo "==> Creando backup de la base de datos..."
            mkdir -p /opt/backup
            BACKUP_FILE="/opt/backup/backup_$(date +%Y%m%d_%H%M%S).sql"
            
            # Verificar que PostgreSQL estÃ© funcionando antes del backup
            if ! docker-compose exec -T postgres pg_isready -U postgres; then
              echo "ERROR: PostgreSQL no estÃ¡ listo para backup"
              exit 3
            fi
            
            # Crear backup
            if docker-compose exec -T postgres pg_dump -U postgres -d personalfit > "$BACKUP_FILE"; then
              echo "âœ… Backup creado exitosamente en: $BACKUP_FILE"
              echo "ðŸ“Š TamaÃ±o del backup: $(du -h "$BACKUP_FILE" | cut -f1)"
            else
              echo "ERROR: FallÃ³ la creaciÃ³n del backup"
              exit 4
            fi

            echo "==> Actualizando repo (origin/main)"
            git fetch --all --prune
            git reset --hard origin/main

            echo "==> Construyendo imÃ¡genes (solo backend + frontend)"
            docker-compose down -v
            docker-compose up -d --build 

            # echo "==> Actualizando servicios (no tocar postgres ni pgadmin)"
            # docker-compose up -d --no-deps personalfit-backend personalfit-frontend

            # FunciÃ³n para esperar estado healthy
            wait_for_healthy() {
              local container="$1"
              local timeout_seconds="${2:-180}"
              local interval=5
              local waited=0

              while [ "$waited" -lt "$timeout_seconds" ]; do
                # Primero intentar el health check nativo de Docker
                local docker_health=$(docker inspect -f '{{.State.Health.Status}}' "$container" 2>/dev/null || echo "no-health-check")
                
                if [ "$docker_health" = "healthy" ]; then
                  echo "$(date +'%F %T') - $container is healthy (Docker health check)"
                  return 0
                elif [ "$docker_health" = "unhealthy" ]; then
                  echo "$(date +'%F %T') - $container is unhealthy (Docker health check)"
                  return 2
                fi
                
                # Si no hay health check nativo o estÃ¡ starting, hacer peticiÃ³n HTTP directa
                 if [ "$container" = "personalfit-backend" ]; then
                   # Para el backend, verificar que responda en el puerto 8080
                   if curl -f -s http://localhost:8080/api/health >/dev/null 2>&1; then
                     echo "$(date +'%F %T') - Backend responding on port 8080"
                     return 0
                   fi
                elif [ "$container" = "personalfit-frontend" ]; then
                  # Para el frontend, verificar que responda en el puerto 3000
                  if curl -f -s http://localhost:3000 >/dev/null 2>&1; then
                    echo "$(date +'%F %T') - Frontend responding on port 3000"
                    return 0
                  fi
                fi
                
                echo "$(date +'%F %T') - Waiting for $container to be ready... (${waited}s/${timeout_seconds}s) - Docker health: $docker_health"
                sleep $interval
                waited=$((waited + interval))
              done

              echo "TIMEOUT: $container did not become ready after ${timeout_seconds}s"
              return 1
            }

            echo "==> Esperando que personalfit-backend estÃ© listo..."
            if ! wait_for_healthy personalfit-backend 30; then
              echo "ERROR: backend no responde en puerto 8080 (endpoint /api/health) -> abortando deploy"
              docker-compose logs --no-color --timestamps personalfit-backend | tail -n 300
              exit 10
            fi

            echo "==> Esperando que personalfit-frontend estÃ© listo..."
            if ! wait_for_healthy personalfit-frontend 30; then
              echo "ERROR: frontend no responde en puerto 3000 -> abortando deploy"
              docker-compose logs --no-color --timestamps personalfit-frontend | tail -n 300
              exit 11
            fi

            echo "==> Limpieza de imÃ¡genes antiguas"
            docker image prune -f

            echo "==> Verificando integridad de la base de datos..."
            # Crear base de datos temporal para test de restauraciÃ³n
            if docker-compose exec -T postgres psql -U postgres -c "CREATE DATABASE test_restore;" 2>/dev/null; then
              echo "ðŸ“‹ Base de datos temporal creada para test"
              
              # Restaurar backup en base temporal
              if docker-compose exec -T postgres psql -U postgres -d test_restore < "$BACKUP_FILE" 2>/dev/null; then
                echo "ðŸ”„ Backup restaurado en base temporal"
                
                # Verificar que se restaurÃ³ correctamente (contar usuarios)
                USER_COUNT=$(docker-compose exec -T postgres psql -U postgres -d test_restore -t -c "SELECT COUNT(*) FROM users;" 2>/dev/null | tr -d ' \n')
                if [ "$USER_COUNT" -ge 0 ] 2>/dev/null; then
                  echo "âœ… VerificaciÃ³n exitosa: $USER_COUNT usuarios encontrados en backup"
                else
                  echo "âš ï¸  VerificaciÃ³n parcial: no se pudo contar usuarios"
                fi
              else
                echo "âš ï¸  No se pudo restaurar backup en base temporal"
              fi
              
              # Limpiar base temporal
              docker-compose exec -T postgres psql -U postgres -c "DROP DATABASE test_restore;" 2>/dev/null
              echo "ðŸ§¹ Base de datos temporal eliminada"
            else
              echo "âš ï¸  No se pudo crear base temporal para test"
            fi

            echo "==> DEPLOY OK: servicios actualizados y healthy"
            echo "ðŸ’¾ Backup disponible en: $BACKUP_FILE"
          REMOTE
