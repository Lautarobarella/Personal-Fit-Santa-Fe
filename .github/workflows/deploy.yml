name: Deploy to Host (password SSH + healthchecks)

on:
  push:
    branches:
      - main

jobs:
  # frontend-tests:
  #   runs-on: ubuntu-latest
  #   steps:
  #     - name: Checkout repo
  #       uses: actions/checkout@v4

  #     - name: Use Node.js 20
  #       uses: actions/setup-node@v4
  #       with:
  #         node-version: '20'

  #     - name: Install dependencies (Frontend)
  #       working-directory: Frontend
  #       run: npm install --no-audit --no-fund

  #     - name: Run frontend tests
  #       working-directory: Frontend
  #       run: npm test --silent

  deploy:
    needs: frontend-tests
    environment: Production
    runs-on: ubuntu-latest
    env:
      SSH_HOST: ${{ secrets.SSH_HOST }}
      SSH_PORT: ${{ secrets.SSH_PORT }}
      SSH_USERNAME: ${{ secrets.SSH_USERNAME }}
      SSH_PASSWORD: ${{ secrets.SSH_PASSWORD }}
      JWT_SECRET: ${{ secrets.JWT_SECRET }}
      MP_ACCESS_TOKEN: ${{ secrets.MP_ACCESS_TOKEN }}
      NEXT_PUBLIC_MP_PUBLIC_KEY: ${{ secrets.NEXT_PUBLIC_MP_PUBLIC_KEY }}
      WEBHOOK_SECRET: ${{ secrets.WEBHOOK_SECRET }}
      
    steps:
      - name: Checkout repo (opcional para tests)
        uses: actions/checkout@v4

      - name: Sanity check de secrets
        run: |
          for v in SSH_HOST SSH_PORT SSH_USERNAME SSH_PASSWORD JWT_SECRET MP_ACCESS_TOKEN NEXT_PUBLIC_MP_PUBLIC_KEY; do
            if [ -z "${!v}" ] || [ "${!v}" = "null" ]; then
              echo "Falta variable $v (revisa environment/Production o nombres)"; exit 1
            fi
          done

      - name: Install sshpass (para autenticaciÃ³n por usuario+password)
        run: sudo apt-get update && sudo apt-get install -y sshpass

      - name: Install Docker Compose V2 (CLI docker-compose)
        run: |
          sudo curl -L "https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
          sudo chmod +x /usr/local/bin/docker-compose
          docker-compose --version

      - name: Deploy to host (ssh via password) and wait healthchecks
        run: |
          # default port
          if [ -z "${SSH_PORT}" ] || [ "${SSH_PORT}" = "null" ]; then
            SSH_PORT=22
          fi

          echo "Conectando a ${SSH_USERNAME}@${SSH_HOST}:${SSH_PORT} ..."
          sshpass -p "${SSH_PASSWORD}" ssh -o StrictHostKeyChecking=no -p "${SSH_PORT}" "${SSH_USERNAME}@${SSH_HOST}" bash -lc '
            set -euo pipefail

            DEPLOY_DIR=/opt/Personal-Fit-Santa-Fe
            echo "==> Entrando en $DEPLOY_DIR"
            cd "$DEPLOY_DIR" || { echo "ERROR: Directorio $DEPLOY_DIR no existe"; exit 2; }

            echo "==> Creando backup de la base de datos..."
            mkdir -p /opt/backups
            BACKUP_FILE="/opt/backups/backup_$(date +%Y%m%d_%H%M%S).sql"

            # Verificar readiness usando envs del contenedor (POSTGRES_USER/DB/PASSWORD)
            if ! docker-compose exec -T postgres bash -lc "PGPASSWORD=\"\$POSTGRES_PASSWORD\" pg_isready -U \"\$POSTGRES_USER\" -d \"\$POSTGRES_DB\""; then
              echo "ERROR: PostgreSQL no estÃ¡ listo para backup"
              exit 3
            fi

            # Crear backup con credenciales del contenedor
            if docker-compose exec -T postgres bash -lc "PGPASSWORD=\"\$POSTGRES_PASSWORD\" pg_dump -U \"\$POSTGRES_USER\" -d \"\$POSTGRES_DB\"" > "$BACKUP_FILE"; then
              echo "âœ… Backup creado: $BACKUP_FILE"
              echo "ðŸ“Š TamaÃ±o: $(du -h "$BACKUP_FILE" | cut -f1)"
            else
              echo "ERROR: FallÃ³ la creaciÃ³n del backup"
              exit 4
            fi

            echo "==> Actualizando repo (origin/main)"
            git fetch --all --prune
            git reset --hard origin/main
            git pull origin main

            echo "==> Construyendo y levantando servicios"
            docker-compose down -v
            
            # Exportar secretos como variables de entorno para docker-compose
            export JWT_SECRET="'"${JWT_SECRET}"'"
            export MP_ACCESS_TOKEN="'"${MP_ACCESS_TOKEN}"'"
            export NEXT_PUBLIC_MP_PUBLIC_KEY="'"${NEXT_PUBLIC_MP_PUBLIC_KEY}"'"
            export WEBHOOK_SECRET="'"${WEBHOOK_SECRET}"'"
            
            docker-compose up -d --build

            # Esperar a Postgres (usa envs del contenedor)
            wait_for_postgres() {
              local timeout="${1:-120}"
              local interval=2
              local waited=0
              while [ "$waited" -lt "$timeout" ]; do
                if docker-compose exec -T postgres bash -lc "PGPASSWORD=\"\$POSTGRES_PASSWORD\" pg_isready -U \"\$POSTGRES_USER\" -d \"\$POSTGRES_DB\"" >/dev/null 2>&1; then
                  echo "$(date +"%F %T") - Postgres ready"
                  return 0
                fi
                echo "$(date +"%F %T") - Esperando Postgres... (${waited}s/${timeout}s)"
                sleep "$interval"
                waited=$((waited + interval))
              done
              return 1
            }

            echo "==> Esperando Postgres..."
            if ! wait_for_postgres 120; then
              echo "ERROR: Postgres no estuvo listo a tiempo"
              docker-compose logs --no-color --timestamps postgres | tail -n 200 || true
              exit 5
            fi

            echo "==> Verificando si necesita restaurar backup..."
            # Verificar si la base de datos tiene datos (especÃ­ficamente la tabla app_user)
            USER_COUNT=$(docker-compose exec -T postgres bash -lc "PGPASSWORD=\"\$POSTGRES_PASSWORD\" psql -U \"\$POSTGRES_USER\" -d \"\$POSTGRES_DB\" -t -c \"SELECT COUNT(*) FROM app_user;\"" 2>/dev/null | tr -d ' \n' || echo "0")
            
            if [ "$USER_COUNT" = "0" ] || [ -z "$USER_COUNT" ]; then
              echo "==> Base de datos vacÃ­a, buscando backup mÃ¡s reciente para restaurar..."
              LATEST_BACKUP=$(ls -1t /opt/backups/backup*.sql 2>/dev/null | head -n1 || echo "")
              
              if [ -n "$LATEST_BACKUP" ] && [ -f "$LATEST_BACKUP" ]; then
                echo "==> Restaurando backup: $LATEST_BACKUP"
                if docker-compose exec -T postgres bash -lc "PGPASSWORD=\"\$POSTGRES_PASSWORD\" psql -U \"\$POSTGRES_USER\" -d \"\$POSTGRES_DB\"" < "$LATEST_BACKUP"; then
                  echo "âœ… Backup restaurado exitosamente"
                  
                  # Verificar que la restauraciÃ³n fue exitosa
                  RESTORED_USER_COUNT=$(docker-compose exec -T postgres bash -lc "PGPASSWORD=\"\$POSTGRES_PASSWORD\" psql -U \"\$POSTGRES_USER\" -d \"\$POSTGRES_DB\" -t -c \"SELECT COUNT(*) FROM app_user;\"" 2>/dev/null | tr -d ' \n' || echo "0")
                  echo "âœ… Usuarios restaurados: $RESTORED_USER_COUNT"
                else
                  echo "âš ï¸  Error al restaurar backup, pero continuando deployment"
                fi
              else
                echo "â„¹ï¸  No se encontrÃ³ backup para restaurar, base de datos iniciarÃ¡ vacÃ­a"
              fi
            else
              echo "â„¹ï¸  Base de datos ya contiene $USER_COUNT usuarios, no se necesita restaurar"
            fi

            wait_for_healthy() {
              local container="$1"
              local timeout_seconds="${2:-180}"
              local interval=5
              local waited=0

              while [ "$waited" -lt "$timeout_seconds" ]; do
                local docker_health
                docker_health=$(docker inspect -f "{{.State.Health.Status}}" "$container" 2>/dev/null || echo "no-health-check")

                if [ "$docker_health" = "healthy" ]; then
                  echo "$(date +"%F %T") - $container healthy (Docker health)"
                  return 0
                elif [ "$docker_health" = "unhealthy" ]; then
                  echo "$(date +"%F %T") - $container unhealthy"
                  return 2
                fi

                if [ "$container" = "personalfit-backend" ]; then
                  if curl -fsS http://localhost:8080/api/health >/dev/null 2>&1; then
                    echo "$(date +"%F %T") - Backend OK en :8080"
                    return 0
                  fi
                elif [ "$container" = "personalfit-frontend" ]; then
                  if curl -fsS http://localhost:3000 >/dev/null 2>&1; then
                    echo "$(date +"%F %T") - Frontend OK en :3000"
                    return 0
                  fi
                fi

                echo "$(date +"%F %T") - Esperando $container... (${waited}s/${timeout_seconds}s) - Docker health: $docker_health"
                sleep $interval
                waited=$((waited + interval))
              done

              echo "TIMEOUT: $container no quedÃ³ listo tras ${timeout_seconds}s"
              return 1
            }

            echo "==> Esperando backend..."
            if ! wait_for_healthy personalfit-backend 60; then
              echo "ERROR: backend no responde -> logs:"
              docker-compose logs --no-color --timestamps personalfit-backend | tail -n 300
              exit 10
            fi

            echo "==> Esperando frontend..."
            if ! wait_for_healthy personalfit-frontend 60; then
              echo "ERROR: frontend no responde -> logs:"
              docker-compose logs --no-color --timestamps personalfit-frontend | tail -n 300
              exit 11
            fi

            echo "==> Limpieza de imÃ¡genes antiguas"
            docker image prune -f

            echo "==> Verificando integridad del backup"
            
            # Verificar que el archivo de backup existe y no estÃ¡ vacÃ­o
            if [ -f "$BACKUP_FILE" ] && [ -s "$BACKUP_FILE" ]; then
              BACKUP_SIZE=$(du -h "$BACKUP_FILE" | cut -f1)
              echo "âœ… Archivo de backup vÃ¡lido: $BACKUP_SIZE"
              
              # Verificar que la base de datos actual coincide con el backup reciÃ©n creado
              echo "==> Verificando consistencia entre backup y base de datos actual..."
              CURRENT_USER_COUNT=$(docker-compose exec -T postgres bash -lc "PGPASSWORD=\"\$POSTGRES_PASSWORD\" psql -U \"\$POSTGRES_USER\" -d \"\$POSTGRES_DB\" -t -c \"SELECT COUNT(*) FROM app_user;\"" 2>/dev/null | tr -d ' \n' || echo "0")
              echo "â„¹ï¸  Usuarios actuales en BD: $CURRENT_USER_COUNT"
              
              # Verificar que el backup contiene SQL vÃ¡lido buscando patrones tÃ­picos
              if grep -q "CREATE TABLE\|INSERT INTO\|COPY.*FROM stdin" "$BACKUP_FILE" 2>/dev/null; then
                echo "âœ… Backup contiene estructura SQL vÃ¡lida"
                
                # Intentar contar lÃ­neas de datos para estimar contenido
                DATA_LINES=$(grep -c "INSERT INTO\|COPY.*FROM stdin" "$BACKUP_FILE" 2>/dev/null || echo 0)
                echo "âœ… Backup contiene $DATA_LINES lÃ­neas de datos"
                
                # Analizar contenido del backup por tabla
                echo "Analizando contenido del backup por tabla..."
                TOTAL_RECORDS=0
                
                # Lista de tablas a verificar (nombres reales segÃºn los modelos)
                TABLES="app_user activity attendance payment payment_file notification app_settings"
                
                for table in $TABLES; do
                  # Buscar lÃ­neas COPY para esta tabla en el backup (mÃ¡s flexible)
                  if grep -q "^COPY public\\.$table" "$BACKUP_FILE" 2>/dev/null; then
                    echo "  ðŸ” Analizando tabla $table..."
                    
                    # Extraer el bloque completo de datos para esta tabla
                    # Desde COPY hasta el prÃ³ximo \.
                    START_LINE=$(grep -n "^COPY public\\.$table" "$BACKUP_FILE" | head -n1 | cut -d: -f1)
                    if [ -n "$START_LINE" ] && [ "$START_LINE" != "" ]; then
                      # Buscar el \\. despuÃ©s de la lÃ­nea COPY
                      RAW_END_LINE=$(tail -n +$((START_LINE + 1)) "$BACKUP_FILE" | grep -n "^\\\\\\.$" | head -n1 | cut -d: -f1)
                      if [ -n "$RAW_END_LINE" ] && [ "$RAW_END_LINE" != "" ]; then
                        # Limpiar cualquier carÃ¡cter extraÃ±o y asegurar que es un nÃºmero
                        END_LINE=$(echo "$RAW_END_LINE" | tr -cd '0-9')
                        if [ -n "$END_LINE" ] && [ "$END_LINE" -gt 0 ]; then
                          # Calcular lÃ­neas de datos (END_LINE - 1 porque excluimos el \\.)
                          COUNT=$((END_LINE - 1))
                          if [ "$COUNT" -gt 0 ]; then
                            echo "  âœ… $table: $COUNT registros en backup"
                            TOTAL_RECORDS=$((TOTAL_RECORDS + COUNT))
                          else
                            echo "  ðŸ“‹ $table: estructura presente, sin datos"
                          fi
                        else
                          echo "  âš ï¸  $table: no se pudo calcular registros"
                        fi
                      else
                        echo "  âš ï¸  $table: estructura encontrada, pero formato inusual"
                      fi
                    else
                      echo "  ðŸ“‹ $table: no se pudo analizar"
                    fi
                  else
                    # Buscar INSERT INTO como alternativa
                    INSERT_COUNT=$(grep -c "^INSERT INTO.*\\.$table\\|^INSERT INTO $table" "$BACKUP_FILE" 2>/dev/null || echo "0")
                    if [ "$INSERT_COUNT" -gt 0 ]; then
                      echo "  âœ… $table: $INSERT_COUNT registros en backup (INSERT)"
                      TOTAL_RECORDS=$((TOTAL_RECORDS + INSERT_COUNT))
                    else
                      echo "  ðŸ“‹ $table: no encontrada en backup"
                    fi
                  fi
                done
                
                if [ "$TOTAL_RECORDS" -gt 0 ]; then
                  echo "âœ… Backup contiene $TOTAL_RECORDS registros totales distribuidos en las tablas"
                else
                  echo "âš ï¸  No se pudieron detectar registros especÃ­ficos en el backup"
                fi
                
                # Verificar que la base actual estÃ© accesible para futuras operaciones
                if docker-compose exec -T postgres bash -lc "PGPASSWORD=\"\$POSTGRES_PASSWORD\" psql -U \"\$POSTGRES_USER\" -d \"\$POSTGRES_DB\" -c \"SELECT 1;\"" 2>/dev/null | grep -q "1"; then
                  echo "âœ… Base de datos actual accesible para futuras operaciones"
                else
                  echo "âš ï¸  Problema de conectividad con la base actual"
                fi
              else
                echo "âš ï¸  Backup no contiene estructura SQL reconocible"
              fi
            else
              echo "âŒ Archivo de backup no existe o estÃ¡ vacÃ­o"
            fi

            echo "==> DEPLOY OK"
            echo "ðŸ’¾ Backup en: $BACKUP_FILE"
          '